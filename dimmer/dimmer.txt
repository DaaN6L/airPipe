Принцип роботи симетричного тиристора (симістора):

- в нормальному стані тиристор закритий (не пропускає струм);
- при пропусканні струму через керуючий електрод тиристор відкривається, і пропускає струм;
- якщо припинити подачу струму в керуючий електрод, тиристор залишається відкритим;
- тиристор закривається, якщо струм через нього зменшується до нуля.

Таким чином, тиристор автоматично забезпечує вимикання при нульовому струмі, що важливо для індуктивних навантажень, таких як мотори. Бо якщо розірвати коло з індуктивним елементом, в якому протікає струм, струм продовжить протікати, і зовсім не там, де потрібно. Простіше кажучи, проб'є.
І другий момент - для відкриття тиристора важливий початковий імпульс, далі керуючий сигнал можна зняти. Зазвичай роблять два коротких імпульси, це пришвидшує відкриття тиристора, що знижує втрати на ньому, а отже й нагрів.

Керування потужністю за допомогою симісторного регулятора здійснюється подачею керуючого сигналу через певний час після моменту переходу змінної напруги через нуль. Це проілюстровано на діаграмі. Сигнал керування позитивний, на діаграмі він зображений негативним для від'ємної півхвилі для наглядності. Потужність визначається як площа під частиною синусоїди від моменту ввімкнення до моменту переходу через нуль. Регулювання потужністю здійснюється зміною моменту відкриття симістора відносно моменту переходу напруги через нуль. Слід мати на увазі, що потужність не є прямо пропорційною часу вікриття симістора. Виведення формули залежності - для самостійного опрацювання :)
Ще може статися так, що швидкість потоку не є прямо пропорційна потужності (наприклад, до 10% потужності вентилятор взагалі не обертається). Це слід дослідити на реальній установці, і за потреби внести необхідні корективи.

Модуль димера має керуючий вхід, а також вихід синхронізації, по якому визначаються моменти переходу напруги мережі через нуль. Розробник модуля застосував максимально дешеве рішення (однополярну оптопару), в результаті фронт та спад синхросигналу не точно відповідають моментам переходу напруги через нуль. Це проілюстровано на діаграмі. І це не є великою проблемою, бо потрібні корективи можна зробити програмно, контролер це дозволяє. Для цього рекомендується визначити моменти часу фронту та спаду, обчислити період сигналу та різницю між тривалістю високого та низького рівня синхросигналу, і додаткову затримку прийняти як четвертину різциці. Основну синхронізацію здійснювати по фронту синхросигналу, оскільки він відбувається до моменту фактичного переходу напруги через нуль, що дає деякий час для обробки. Керуючий сигнал подати через dl+dt після фронту синхросиглалу, тут dl - затримка, що залежить від потрібної потужності, а dt - додаткова затримка, згадана вище. Ці затримки задавати в мікросекундах. Таким чином здійснюється відкриття симістора на від'ємній півхвилі напруги. Для додатньої півхвилі - подати сигнал через половину періода після моменту подачі сигналу для від'ємної півхвилі.


Переривання.
Це механізм реакції контролера на певну подію. В даному випадку такими подіями є зміна рівня напруги на виводі (синхросигналу), а також завершення відліку таймера. Таймер - це модуль в складі контролера, який здійснює відлік часу в порціях тактового сигналу. Таймер можна запустити, зупинити, а також налаштувати, щоб він генерував переривання в певний момент часу. Таймер має й інші можливості, але то для самостійного ознайомлення.
Якщо на певну подію налаштовано переривання, то в момент настання події виконання основного алгоритму програми призупиняється, і виконується функція, призначена для цього переривання. Після виконання функції переривання основний алгоритм продовжує виконання з місця зупинки. Очевидно, що функції переривання слід робити максимально короткими, щоб не порушувати виконання основного алгоритму. Всі обчислення, що не є критичними, потрібно винести з функцій переривання в основний цикл програми.

Механізми ESP32 для реалізації переривань для даного випадку.


  attachInterrupt( SYNCRO_PIN, syncro_callback, CHANGE); //номер виводу, функція переривання, реакція - на зміну стану

  void IRAM_ATTR syncro_callback() { } //функція переривання


  hw_timer_t *ht = NULL; //timer handle, must be global variable

  ht = timerBegin(1,80,true); //Ініціалізація таймера, параметри - номер таймера, період (80 - 1 мкс), відлік на зростання

  timerAttachInterrupt(ht, &timer_callback, true); //підключення переривання до таймера

  void IRAM_ATTR timer_callback() { } //Функція переривання таймера

//запуск таймера, розміщується в обох процедурах переривання, змінюється лише параметр часу

    timerAlarmWrite(ht,dl,false); //dl - затримка в мікросекундах, false - виконати тільки один раз
    timerRestart(ht); //скинути лічильник таймера, на всяк випадок
    timerAlarmEnable(ht); //власне запуск таймера
    //якщо все зроблено вірно, то через dl мікросекунд виконається функція timer_callback

